# Diário de Estudos / Projeto BIA

## Início do Projeto 11/09/2025

> "Nós somos o que fazemos repetidamente.
> Excelência, portanto, não é um ato, mas um hábito." *Aristóteles*

1. Participei da reunião com o professor Pablo Sampaio e o antigo bolsista Gabriel Belo.
     1. ***Acertamos os pontos a serem trabalhados nos próximos dias.***
   
2. Na parte da tarde tive aula na **UFRPE** de programação orientada a objetos.
     1. ***Aprendi um pouco sobre tipos primitivos.***
   
3. Na parte da noite acessei o guia sobre **Markdown** e estou colocando em prática alguns pontos.
     1. ***Aprendi a visão geral sobre a linguagem de marcação **Markdown**.***
     2. ***Aprendi também sobre Títulos, Parágrafos, Quebras de Linha, Ênfase, Citações em Bloco e Listas.***
4. Seguindo a ordem de prioridade definida em reunião os próximos avanços serão:
 - Revisar os pontos já aprendidos nesse primeiro dia em Markdown.
 - Continuar o estudo de Listas, Código, Regras Horizontais, Ligações, Imagens, Caracteres de Escape e HTML.
 - Estudar fórmulas matemáticas em Latex.
 - Aprender como criar páginas no Github Pages
 - Aprender os comandos básicos de Git.
  # Por fim 
  ## Reflexão Matemática
***Podemos representar matematicamente a frase de Aristóteles que fala sobre hábitos e repetição:***
> $$
> \lim_{x \to \infty} \text{Esforço}(x) = \text{Excelência}
> $$
>> Ou seja quando o esforço é contínuo e tende ao infinito, acaba convergindo para a excelência.

## 12/09/2025

- Iniciei o dia revisando os pontos estudados em Markdown no dia anterior.

- Estudei os conteúdos que faltavam no [Guia de Markdown](https://www.markdownguide.org/basic-syntax/#overview). 
  1. Listas
  2. Código
  3. Regras Horizontais
  4. Ligações
  5. Imagens
  6. Caracteres de escape 
  7. HTML
   
- Na parte da tarde tive aula na **UFRPE** de Matemática Discreta 2.
    #  Estudo de Matemática Discreta 2  
## Permutação e Combinação

---

## 1. Introdução
No estudo da **Análise Combinatória**, trabalhamos com técnicas para **contar** quantas maneiras diferentes podemos organizar ou escolher elementos de um conjunto finito, sem precisar listar todas as possibilidades.

Dois conceitos centrais são:  
- **Permutação**: quando a **ordem** importa.  
- **Combinação**: quando a **ordem não importa**.

---

## 2. Fatorial (!)
O fatorial é a base da análise combinatória.  
Definição:  
$$
n! = n \cdot (n-1) \cdot (n-2) \cdot \dots \cdot 2 \cdot 1
$$

>Exemplo:  
$$
5! = 5 \cdot 4 \cdot 3 \cdot 2 \cdot 1 = 120
$$

---

## 3. Permutação
### 3.1 Permutação Simples
Dado um conjunto com *n* elementos distintos, o número de maneiras de organizá-los em **todas as posições possíveis** é:
$$
P_n = n!
$$

>- Exemplo:  
Quantas maneiras diferentes podemos organizar as letras da palavra **"SOL"**?  
$$
P_3 = 3! = 6
$$
Listando: SOL, SLO, OSL, OLS, LSO, LOS.

---

### 3.2 Permutação com Repetição
Se alguns elementos se repetem, devemos **dividir** pelo fatorial da quantidade de repetições:

$$
P = \frac{n!}{n_1! \cdot n_2! \cdot \dots \cdot n_k!}
$$

>- Exemplo:  
Quantas permutações diferentes da palavra **"ANA"**?  
>>- 3 letras no total  
>>- 'A' repete 2 vezes  
$$
P = \frac{3!}{2!} = 3
$$ 
As permutações: ANA, AAN, NAA.

---

## 4. Arranjo
O **arranjo** é quando escolhemos apenas **k posições** de um total de \( n \), **considerando a ordem**.

$$
A_{n,k} = \frac{n!}{(n-k)!}
$$

>- Exemplo:  
Quantos números de 2 algarismos distintos podem ser formados com {1,2,3}?  
$$
A_{3,2} = \frac{3!}{(3-2)!} = \frac{6}{1} = 6
$$
(12, 13, 21, 23, 31, 32).

---

## 5. Combinação
Na **combinação**, a ordem **não importa**.  
A fórmula é:
$$
C_{n,k} = \binom{n}{k} = \frac{n!}{k!(n-k)!}
$$

>- Exemplo:  
De um grupo de 5 pessoas, de quantas formas podemos escolher uma **comissão de 2 pessoas**?  
$$
C_{5,2} = \frac{5!}{2!(5-2)!} = \frac{120}{2 \cdot 6} = 10
$$

Lista (sem ordem): {1,2}, {1,3}, {1,4}, {1,5}, {2,3}, {2,4}, {2,5}, {3,4}, {3,5}, {4,5}.

---

## 6. Diferença entre Permutação e Combinação
- **Permutação**: todos os elementos, ordem importa.  
- **Arranjo**: parte dos elementos, ordem importa.  
- **Combinação**: parte dos elementos, ordem não importa.

---

## 7. Resumo Visual

| Conceito         | Ordem Importa? | Todos ou Parte? | Fórmula |
|------------------|----------------|-----------------|---------|
| Permutação       | Sim         | Todos           |$P_n = n!$|
| Arranjo          | Sim         | Parte (k)       |$A_{n,k} = \frac{n!}{(n-k)!}$ |
| Combinação       | Não         | Parte (k)       |$C_{n,k} = \frac{n!}{k!(n-k)!}$|
---
## 15/09/2025

- Como visto anteriormente também já apliquei algumas **fórmulas matemáticas em Latex.** *Esse diário está sendo escrito de modo construtivo e não linear. Por isso conteúdos estudados depois podem ser adicionados no início.* (I can add that I also studied on the weekend but I thought it was better to format along with the week)
- Abaixo vamos decorrer sobre algumas fórmulas matemáticas pela definição:
> **Fórmula de Limite**
> $$
> \lim_{x \to a} f(x) = L
> $$
> Explicação: estamos dizendo que os valores de **f(x)** ficam tão próximos de **L** quanto quisermos, desde que **x** esteja suficientemente perto de **a**, mas **sem precisar que x = a.**

> **Fórmula de Derivada**
>$$
>f' (x) = \lim_{h \to 0} \frac{f(x+h) - f(x)}{h}
>$$
> Explicação: a derivada mostra **como uma função muda em cada ponto.** É como medir a **inclinação da curva** naquele instante. Ela pega a variação da função em um intervalo bem pequeno e transforma na **inclinação da tangente.**

- Também tive aula de programação orientada a objetos.
     1. Foi falado sobre fundamentos da notação UML (representação de uma classe)
     2. Também sobre especificação e implementação de associação simples entre classes
     3. Agregação e composição.
>>>>>>> 45eb316 (Atualização correta)
## 16/09/2025

- Iniciei o dia aplicando os conhecimentos adquiridos ao longo dos últimos dias para a construção deste diário.
- Estudei sobre como criar e hospedar sites estáticos diretamente de um repositório no GitHub utilizando o **GitHub Pages**.
- Aprendi os comandos essenciais do **Git** para controle de versão, como `git init`, `git clone`, `git add`, `git commit`, `git status`, `git push` e `git pull`.
- Na parte da tarde, comecei a aprofundar meus conhecimentos em lógica de programação com um resumo sobre Algoritmos e Estruturas de Dados.

# Estudo de Algoritmos e Estrutura de Dados

## Parte 1: Algoritmos

### 1. Introdução
Um **algoritmo** é uma sequência finita e bem definida de passos lógicos para resolver um problema ou executar uma tarefa. É a "receita" que um computador segue. Para ser considerado um algoritmo, ele deve ser não ambíguo, ter um início e um fim, e ser eficaz na solução do problema proposto.

### 2. Pseudolinguagem
A **pseudolinguagem** (ou Português Estruturado) é uma forma genérica de escrever um algoritmo, utilizando uma linguagem simples e nativa, sem se prender às regras de sintaxe de uma linguagem de programação específica. Ela serve como uma ponte entre a linguagem humana e a linguagem de máquina, facilitando o planejamento e a compreensão da lógica.

> **Exemplo: Algoritmo para verificar se um aluno foi aprovado**
> ```
> ALGORITMO "VerificaAprovacao"
> DECLARE nota1, nota2, media: REAL
>
> INÍCIO
>   ESCREVA "Digite a primeira nota: "
>   LEIA nota1
>
>   ESCREVA "Digite a segunda nota: "
>   LEIA nota2
>
>   media <- (nota1 + nota2) / 2
>
>   SE media >= 7 ENTÃO
>     ESCREVA "Aluno Aprovado!"
>   SENÃO
>     ESCREVA "Aluno Reprovado."
>   FIMSE
> FIM
> ```

### 3. Análise de Complexidade
A análise de complexidade mede a eficiência de um algoritmo, avaliando quanto tempo (complexidade de tempo) ou memória (complexidade de espaço) ele consome em função do tamanho da entrada ($n$). A **Notação Big O** é a mais comum para essa análise, descrevendo o pior cenário de crescimento.

**Exemplos Comuns:**
-   **$O(1)$ (Constante)**: O desempenho é o mesmo, não importa o tamanho da entrada. Ex: Acessar um item em um vetor pelo seu índice.
-   **$O(n)$ (Linear)**: O tempo de execução cresce proporcionalmente ao tamanho da entrada. Ex: Percorrer todos os elementos de uma lista.
-   **$O(n^2)$ (Quadrático)**: O tempo de execução cresce pelo quadrado do tamanho da entrada. Geralmente ocorre com laços de repetição aninhados.

---

## Parte 2: Estruturas de Dados Sequenciais

### 1. Alocação Sequencial
A **alocação sequencial** é uma técnica onde os elementos de uma estrutura de dados são armazenados em posições contíguas (vizinhas) na memória do computador. Isso permite o acesso rápido a qualquer elemento através de um cálculo de endereço simples, geralmente usando um índice. A principal estrutura que utiliza essa alocação é o array (vetor).

### 2. Listas Lineares Sequenciais (Estáticas)
Também conhecidas como **arrays** ou **vetores**, são estruturas de dados que armazenam uma coleção de elementos de mesmo tipo em um bloco contíguo de memória. Sua principal característica é o **tamanho fixo**, definido no momento da sua criação. O acesso a um elemento é muito rápido ($O(1)$), pois basta saber o índice para calcular sua posição na memória.

-   **Vantagem**: Acesso rápido aos elementos.
-   **Desvantagem**: Tamanho estático, o que pode levar a desperdício de memória ou falta de espaço.

### 3. Pilhas e Filas
São duas estruturas de dados lineares abstratas que podem ser implementadas usando alocação sequencial (arrays). Elas se diferenciam pela política de acesso aos dados.

-   **Pilha (Stack)**: Segue o princípio **LIFO (Last-In, First-Out)**, ou seja, o último elemento a entrar é o primeiro a sair.
    -   **Analogia**: Uma pilha de pratos. Você coloca (empilha) um prato no topo e só pode remover (desempilhar) o prato que está no topo.
    -   **Operações principais**: `push` (empilhar) e `pop` (desempilhar).

-   **Fila (Queue)**: Segue o princípio **FIFO (First-In, First-Out)**, ou seja, o primeiro elemento a entrar é o primeiro a sair.
    -   **Analogia**: Uma fila de banco. A primeira pessoa que chega é a primeira a ser atendida.
    -   **Operações principais**: `enqueue` (enfileirar) e `dequeue` (desenfileirar).