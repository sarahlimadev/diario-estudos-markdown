## 16/09/2025

- Iniciei o dia aplicando os conhecimentos adquiridos ao longo dos últimos dias para a construção deste diário.
- Estudei sobre como criar e hospedar sites estáticos diretamente de um repositório no GitHub utilizando o **GitHub Pages**.
- Aprendi os comandos essenciais do **Git** para controle de versão, como `git init`, `git clone`, `git add`, `git commit`, `git status`, `git push` e `git pull`.
- Na parte da tarde, comecei a aprofundar meus conhecimentos em lógica de programação com um resumo sobre Algoritmos e Estruturas de Dados.

# Estudo de Algoritmos e Estrutura de Dados

## Parte 1: Algoritmos

### 1. Introdução
Um **algoritmo** é uma sequência finita e bem definida de passos lógicos para resolver um problema ou executar uma tarefa. É a "receita" que um computador segue. Para ser considerado um algoritmo, ele deve ser não ambíguo, ter um início e um fim, e ser eficaz na solução do problema proposto.

### 2. Pseudolinguagem
A **pseudolinguagem** (ou Português Estruturado) é uma forma genérica de escrever um algoritmo, utilizando uma linguagem simples e nativa, sem se prender às regras de sintaxe de uma linguagem de programação específica. Ela serve como uma ponte entre a linguagem humana e a linguagem de máquina, facilitando o planejamento e a compreensão da lógica.

> **Exemplo: Algoritmo para verificar se um aluno foi aprovado**
> ```
> ALGORITMO "VerificaAprovacao"
> DECLARE nota1, nota2, media: REAL
>
> INÍCIO
>   ESCREVA "Digite a primeira nota: "
>   LEIA nota1
>
>   ESCREVA "Digite a segunda nota: "
>   LEIA nota2
>
>   media <- (nota1 + nota2) / 2
>
>   SE media >= 7 ENTÃO
>     ESCREVA "Aluno Aprovado!"
>   SENÃO
>     ESCREVA "Aluno Reprovado."
>   FIMSE
> FIM
> ```

### 3. Análise de Complexidade
A análise de complexidade mede a eficiência de um algoritmo, avaliando quanto tempo (complexidade de tempo) ou memória (complexidade de espaço) ele consome em função do tamanho da entrada ($n$). A **Notação Big O** é a mais comum para essa análise, descrevendo o pior cenário de crescimento.

**Exemplos Comuns:**
-   **$O(1)$ (Constante)**: O desempenho é o mesmo, não importa o tamanho da entrada. Ex: Acessar um item em um vetor pelo seu índice.
-   **$O(n)$ (Linear)**: O tempo de execução cresce proporcionalmente ao tamanho da entrada. Ex: Percorrer todos os elementos de uma lista.
-   **$O(n^2)$ (Quadrático)**: O tempo de execução cresce pelo quadrado do tamanho da entrada. Geralmente ocorre com laços de repetição aninhados.

---

## Parte 2: Estruturas de Dados Sequenciais

### 1. Alocação Sequencial
A **alocação sequencial** é uma técnica onde os elementos de uma estrutura de dados são armazenados em posições contíguas (vizinhas) na memória do computador. Isso permite o acesso rápido a qualquer elemento através de um cálculo de endereço simples, geralmente usando um índice. A principal estrutura que utiliza essa alocação é o array (vetor).

### 2. Listas Lineares Sequenciais (Estáticas)
Também conhecidas como **arrays** ou **vetores**, são estruturas de dados que armazenam uma coleção de elementos de mesmo tipo em um bloco contíguo de memória. Sua principal característica é o **tamanho fixo**, definido no momento da sua criação. O acesso a um elemento é muito rápido ($O(1)$), pois basta saber o índice para calcular sua posição na memória.

-   **Vantagem**: Acesso rápido aos elementos.
-   **Desvantagem**: Tamanho estático, o que pode levar a desperdício de memória ou falta de espaço.

### 3. Pilhas e Filas
São duas estruturas de dados lineares abstratas que podem ser implementadas usando alocação sequencial (arrays). Elas se diferenciam pela política de acesso aos dados.

-   **Pilha (Stack)**: Segue o princípio **LIFO (Last-In, First-Out)**, ou seja, o último elemento a entrar é o primeiro a sair.
    -   **Analogia**: Uma pilha de pratos. Você coloca (empilha) um prato no topo e só pode remover (desempilhar) o prato que está no topo.
    -   **Operações principais**: `push` (empilhar) e `pop` (desempilhar).

-   **Fila (Queue)**: Segue o princípio **FIFO (First-In, First-Out)**, ou seja, o primeiro elemento a entrar é o primeiro a sair.
    -   **Analogia**: Uma fila de banco. A primeira pessoa que chega é a primeira a ser atendida.
    -   **Operações principais**: `enqueue` (enfileirar) e `dequeue` (desenfileirar).